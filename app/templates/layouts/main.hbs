<!DOCTYPE html>
<html lang="en" class="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{#if title}}{{title}}{{else}}ft_transcendence{{/if}}</title>
    {{> partials/head}}
</head>

<body class="min-h-lvh flex flex-col bg-bg text-fg">
    {{> partials/header}}
    <div class="w-full min-h-lvh backdrop-blur-[1px]">


    <div class="flex flex-1 relative">
        <div class="layout pt-14">
            <main id="app-content" class="flex-1 transition-all duration-300 bg-bg">
                {{{body}}}
            </main>
        </div>

        <!-- Sidebar Overlay (for mobile) -->
        <div id="sidebar-overlay" class="fixed inset-0 bg-bg/50 opacity-0 transition-opacity duration-300 ease-in-out pointer-events-none z-10 md:hidden"></div>

        <!-- Right Sidebar -->
        <aside id="sidebar" class="flex flex-col bg-bg fixed top-0 right-0 w-[300px] h-screen overflow-hidden bg-background border-l border-border shadow-lg translate-x-full transition-transform duration-300 ease-[cubic-bezier(0.32,0.72,0,1)] z-20 text-sidebar-foreground">
                <div id="sidebar-content" class="pt-14 flex h-full flex-col">
                    {{> components/chat/wrapper}}
                </div>
        </aside>
    </div>

    {{> partials/footer}}
    <script type="module" src="/js/router.js"></script>
    <script type="module" src="/js/sidebar.js"></script>
    <script type="module" src="/js/logout.js"></script>
    </div>
</body>


<!-- ▸ Animated black–&–white contour-line background  ──────────────── -->
<script>
  /* ---------------------------------------------------------------------
     Tiny Simplex-noise implementation – MIT © Jonas Wagner, trimmed
     https://github.com/jwagner/simplex-noise.js
  ------------------------------------------------------------------------*/
  class SimplexNoise {
    constructor(r = Math.random) {
      const p = new Uint8Array(256);
      for (let i = 0; i < 256; i++) p[i] = i;
      for (let i = 255; i > 0; i--) {
        const n = Math.floor((i + 1) * r());
        [p[i], p[n]] = [p[n], p[i]];
      }
      this.perm = new Uint8Array(512);
      this.permMod12 = new Uint8Array(512);
      for (let i = 0; i < 512; i++) {
        this.perm[i]      = p[i & 255];
        this.permMod12[i] = this.perm[i] % 12;
      }
    }
    noise3D(xin, yin, zin) {
      const grad3 = [
        [1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
        [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
        [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
      ];
      const F3 = 1/3, G3 = 1/6;
      let n0=0,n1=0,n2=0,n3=0;
      const s = (xin+yin+zin)*F3;
      const i = Math.floor(xin+s), j = Math.floor(yin+s), k = Math.floor(zin+s);
      const t = (i+j+k)*G3;
      const X0 = i-t, Y0 = j-t, Z0 = k-t;
      const x0 = xin-X0, y0 = yin-Y0, z0 = zin-Z0;
      let i1,j1,k1, i2,j2,k2;
      if (x0>=y0) {
        if (y0>=z0) {i1=1;j1=0;k1=0; i2=1;j2=1;k2=0;}
        else if (x0>=z0) {i1=1;j1=0;k1=0; i2=1;j2=0;k2=1;}
        else {i1=0;j1=0;k1=1; i2=1;j2=0;k2=1;}
      } else {
        if (y0<z0) {i1=0;j1=0;k1=1; i2=0;j2=1;k2=1;}
        else if (x0<z0) {i1=0;j1=1;k1=0; i2=0;j2=1;k2=1;}
        else {i1=0;j1=1;k1=0; i2=1;j2=1;k2=0;}
      }
      const x1=x0-i1+G3, y1=y0-j1+G3, z1=z0-k1+G3;
      const x2=x0-i2+2*G3, y2=y0-j2+2*G3, z2=z0-k2+2*G3;
      const x3=x0-1+3*G3, y3=y0-1+3*G3, z3=z0-1+3*G3;
      const ii=i&255, jj=j&255, kk=k&255;
      const gi0=this.permMod12[ii+this.perm[jj+this.perm[kk]]];
      const gi1=this.permMod12[ii+i1+this.perm[jj+j1+this.perm[kk+k1]]];
      const gi2=this.permMod12[ii+i2+this.perm[jj+j2+this.perm[kk+k2]]];
      const gi3=this.permMod12[ii+1+this.perm[jj+1+this.perm[kk+1]]];
      const t0=0.6-(x0*x0+y0*y0+z0*z0);
      if (t0>0){ const t0sq=t0*t0; n0=t0sq*t0sq*(grad3[gi0][0]*x0+grad3[gi0][1]*y0+grad3[gi0][2]*z0);}
      const t1=0.6-(x1*x1+y1*y1+z1*z1);
      if (t1>0){ const t1sq=t1*t1; n1=t1sq*t1sq*(grad3[gi1][0]*x1+grad3[gi1][1]*y1+grad3[gi1][2]*z1);}
      const t2=0.6-(x2*x2+y2*y2+z2*z2);
      if (t2>0){ const t2sq=t2*t2; n2=t2sq*t2sq*(grad3[gi2][0]*x2+grad3[gi2][1]*y2+grad3[gi2][2]*z2);}
      const t3=0.6-(x3*x3+y3*y3+z3*z3);
      if (t3>0){ const t3sq=t3*t3; n3=t3sq*t3sq*(grad3[gi3][0]*x3+grad3[gi3][1]*y3+grad3[gi3][2]*z3);}
      return 32*(n0+n1+n2+n3);
    }
  }

  /* ---------------------------------------------------------------------
     Canvas setup
  ------------------------------------------------------------------------*/
  const simplex = new SimplexNoise();
  const cvs  = document.createElement('canvas');
  const ctx  = cvs.getContext('2d');
  cvs.style.cssText = `
  position: fixed;
  inset: 0;
  width:100%;
  height:100%;
  z-index:-1;           /* keep under site content */
  pointer-events:none;  /* click-through */
`;
  document.body.prepend(cvs);

  function fit() {
    const ratio = window.devicePixelRatio || 1;
    cvs.width  = innerWidth  * ratio;
    cvs.height = innerHeight * ratio;
    ctx.scale(ratio, ratio);
  }
  addEventListener('resize', fit); fit();

  /* ---------------------------------------------------------------------
     Render loop
  ------------------------------------------------------------------------*/
  const SCALE   = 400;   // bigger = wider features
  const LEVELS  = 6;    // number of contour bands
  const THICK   = 0.05;  // line thickness
  const STEP    = 4;     // drawing resolution
  const SPEED   = 0.0008; // flow speed

  let t = 0;
  function frame() {
    t += SPEED;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, cvs.width, cvs.height);
    ctx.fillStyle = '#fff';

    for (let y = 0; y < innerHeight; y += STEP) {
      for (let x = 0; x < innerWidth; x += STEP) {
        const v = (simplex.noise3D(x / SCALE, y / SCALE, t) + 1) * 0.8; // 0-1
        const band = Math.floor(v * LEVELS) / LEVELS;
        if (Math.abs(v - band) < THICK) {
          ctx.fillRect(x, y, STEP, STEP);
        }
      }
    }
    requestAnimationFrame(frame);
  }
  frame();
</script>
<!-- ─────────────────────────────────────────────────────────────────── -->

</html>


